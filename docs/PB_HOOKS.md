Extend with Go - Event hooks
The standard way to modify PocketBase is through event hooks in your Go code.

All hooks have 3 main methods:
- Bind(handler) adds a new handler to the specified event hook. A handler has 3 fields:
- Id (optional) - the name of the handler (could be used as argument for Unbind)
- Priority (optional) - the execution order of the handler (if empty fallbacks to the order of registration in the code).
- Func (required) - the handler function.

BindFunc(func) is similar to Bind but registers a new handler from just the provided function.
The registered handler is added with a default 0 priority and the id is autogenerated (the returned string value).

Trigger(event, oneOffHandlerFuncs...) triggers the event hook.
This method rarely has to be called manually by users.

To remove an already registered hook handler, you can use the handler id and pass it to Unbind(id) or remove all handlers with UnbindAll() (!including system handlers).

All hook handler functions share the same func(e T) error signature and expect the user to call e.Next() if they want to proceed with the execution chain.

If you need to access the app instance from inside a hook handler, prefer using the e.App field instead of reusing a parent scope app variable because the hook could be part of a DB transaction and can cause deadlock.

Also avoid using global mutex locks inside a hook handler because it could be invoked recursively (e.g. cascade delete) and can cause deadlock.


Intercepting logs write
If you want to modify the log data before persisting in the database or to forward it to an external system, then you can listen for changes of the _logs table by attaching to the base model hooks. For example:

app.OnModelCreate(core.LogsTableName).BindFunc(func(e *core.ModelEvent) error {
    l := e.Model.(*core.Log)

    fmt.Println(l.Id)
    fmt.Println(l.Created)
    fmt.Println(l.Level)
    fmt.Println(l.Message)
    fmt.Println(l.Data)

    return e.Next()
})



## store
app.Store() returns a concurrent-safe application memory store that you can use to store anything for the duration of the application process (e.g. cache, config flags, etc.).

You can find more details about the available store methods in the store.Store documentation but the most commonly used ones are Get(key), Set(key, value) and GetOrSet(key, setFunc).

app.Store().Set("example", 123)

v1 := app.Store().Get("example").(int) // 123

v2 := app.Store().GetOrSet("example2", func() any {
    // this setter is invoked only once unless "example2" is removed
    // (e.g. suitable for instantiating singletons)
    return 456
}).(int) // 456
Keep in mind that the application store is also used internally usually with pb* prefixed keys (e.g. the collections cache is stored under the pbAppCachedCollections key) and changing these system keys or calling RemoveAll()/Reset() could have unintended side-effects.

If you want more advanced control you can initialize your own store independent from the application instance via store.New[K, T](nil).