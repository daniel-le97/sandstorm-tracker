// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: stats.sql

package db

import (
	"context"
)

const getPlayerStats = `-- name: GetPlayerStats :one

SELECT
    p.name as player_name,
    p.external_id as external_id,
    COALESCE(k.total_kills, 0) as total_kills,
    COALESCE(d.total_deaths, 0) as total_deaths,
    COALESCE(k.team_kills, 0) as team_kills,
    COALESCE(k.suicides, 0) as suicides,
    CASE WHEN COALESCE(d.total_deaths,0)=0 THEN COALESCE(k.total_kills,0) ELSE ROUND(CAST(COALESCE(k.total_kills,0) AS FLOAT)/CAST(COALESCE(d.total_deaths,0) AS FLOAT),2) END as kdr
FROM players p
LEFT JOIN (
  SELECT killer_id, SUM(CASE WHEN is_team_kill=0 AND is_suicide=0 THEN 1 ELSE 0 END) as total_kills,
         SUM(CASE WHEN is_team_kill=1 THEN 1 ELSE 0 END) as team_kills,
         SUM(CASE WHEN is_suicide=1 THEN 1 ELSE 0 END) as suicides
  FROM kills WHERE kills.server_id = ? GROUP BY killer_id
) k ON p.id = k.killer_id
LEFT JOIN (
  SELECT killer_id as victim_id, COUNT(*) as total_deaths FROM kills WHERE kills.server_id = ? GROUP BY killer_id
) d ON p.id = d.victim_id
WHERE p.external_id = ?
`

type GetPlayerStatsParams struct {
	ServerID   int64
	ServerID_2 int64
	ExternalID string
}

type GetPlayerStatsRow struct {
	PlayerName  string
	ExternalID  string
	TotalKills  float64
	TotalDeaths int64
	TeamKills   float64
	Suicides    float64
	Kdr         interface{}
}

// Player statistics queries
func (q *Queries) GetPlayerStats(ctx context.Context, arg GetPlayerStatsParams) (GetPlayerStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getPlayerStats, arg.ServerID, arg.ServerID_2, arg.ExternalID)
	var i GetPlayerStatsRow
	err := row.Scan(
		&i.PlayerName,
		&i.ExternalID,
		&i.TotalKills,
		&i.TotalDeaths,
		&i.TeamKills,
		&i.Suicides,
		&i.Kdr,
	)
	return i, err
}

const getPlayerStatsGlobal = `-- name: GetPlayerStatsGlobal :one
SELECT p.external_id as external_id, MIN(p.name) as player_name, COALESCE(SUM(k.total_kills),0) as total_kills, COALESCE(SUM(d.total_deaths),0) as total_deaths,
  CASE WHEN COALESCE(SUM(d.total_deaths),0)=0 THEN COALESCE(SUM(k.total_kills),0) ELSE ROUND(CAST(COALESCE(SUM(k.total_kills),0) AS FLOAT)/CAST(COALESCE(SUM(d.total_deaths),0) AS FLOAT),2) END as kdr
FROM players p
LEFT JOIN (SELECT killer_id, SUM(CASE WHEN is_team_kill=0 AND is_suicide=0 THEN 1 ELSE 0 END) as total_kills FROM kills GROUP BY killer_id) k ON p.id = k.killer_id
LEFT JOIN (SELECT killer_id as victim_id, COUNT(*) as total_deaths FROM kills GROUP BY killer_id) d ON p.id = d.victim_id
WHERE p.external_id = ?
GROUP BY p.external_id
`

type GetPlayerStatsGlobalRow struct {
	ExternalID  string
	PlayerName  interface{}
	TotalKills  interface{}
	TotalDeaths interface{}
	Kdr         interface{}
}

func (q *Queries) GetPlayerStatsGlobal(ctx context.Context, externalID string) (GetPlayerStatsGlobalRow, error) {
	row := q.db.QueryRowContext(ctx, getPlayerStatsGlobal, externalID)
	var i GetPlayerStatsGlobalRow
	err := row.Scan(
		&i.ExternalID,
		&i.PlayerName,
		&i.TotalKills,
		&i.TotalDeaths,
		&i.Kdr,
	)
	return i, err
}

const getTopPlayers = `-- name: GetTopPlayers :many
SELECT p.name as player_name, COALESCE(k.total_kills,0) as total_kills, COALESCE(d.total_deaths,0) as total_deaths,
  CASE WHEN COALESCE(d.total_deaths,0)=0 THEN COALESCE(k.total_kills,0) ELSE ROUND(CAST(COALESCE(k.total_kills,0) AS FLOAT)/CAST(COALESCE(d.total_deaths,0) AS FLOAT),2) END as kdr
FROM players p
LEFT JOIN (SELECT killer_id, SUM(CASE WHEN is_team_kill=0 AND is_suicide=0 THEN 1 ELSE 0 END) as total_kills FROM kills WHERE kills.server_id = ? GROUP BY killer_id) k ON p.id = k.killer_id
LEFT JOIN (SELECT killer_id as victim_id, COUNT(*) as total_deaths FROM kills WHERE kills.server_id = ? GROUP BY killer_id) d ON p.id = d.victim_id
WHERE COALESCE(k.total_kills,0) > 0
ORDER BY total_kills DESC, kdr DESC
LIMIT ?
`

type GetTopPlayersParams struct {
	ServerID   int64
	ServerID_2 int64
	Limit      int64
}

type GetTopPlayersRow struct {
	PlayerName  string
	TotalKills  float64
	TotalDeaths int64
	Kdr         interface{}
}

func (q *Queries) GetTopPlayers(ctx context.Context, arg GetTopPlayersParams) ([]GetTopPlayersRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopPlayers, arg.ServerID, arg.ServerID_2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopPlayersRow
	for rows.Next() {
		var i GetTopPlayersRow
		if err := rows.Scan(
			&i.PlayerName,
			&i.TotalKills,
			&i.TotalDeaths,
			&i.Kdr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
