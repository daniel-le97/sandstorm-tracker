// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sessions.sql

package db

import (
	"context"
	"time"
)

const endSession = `-- name: EndSession :exec
UPDATE match_participant
SET leave_time = ?
WHERE id = ?
`

type EndSessionParams struct {
	LeaveTime *time.Time
	ID        int64
}

func (q *Queries) EndSession(ctx context.Context, arg EndSessionParams) error {
	_, err := q.db.ExecContext(ctx, endSession, arg.LeaveTime, arg.ID)
	return err
}

const getActiveSessions = `-- name: GetActiveSessions :many
SELECT mp.id, mp.player_id, mp.match_id, mp.join_time, mp.leave_time, mp.team, mp.created_at, p.name as player_name, p.external_id as external_id
FROM match_participant mp
JOIN matches m ON mp.match_id = m.id
JOIN players p ON mp.player_id = p.id
WHERE m.server_id = ? AND mp.leave_time IS NULL
`

type GetActiveSessionsRow struct {
	ID         int64
	PlayerID   int64
	MatchID    int64
	JoinTime   *time.Time
	LeaveTime  *time.Time
	Team       *int64
	CreatedAt  *time.Time
	PlayerName string
	ExternalID string
}

func (q *Queries) GetActiveSessions(ctx context.Context, serverID int64) ([]GetActiveSessionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getActiveSessions, serverID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetActiveSessionsRow
	for rows.Next() {
		var i GetActiveSessionsRow
		if err := rows.Scan(
			&i.ID,
			&i.PlayerID,
			&i.MatchID,
			&i.JoinTime,
			&i.LeaveTime,
			&i.Team,
			&i.CreatedAt,
			&i.PlayerName,
			&i.ExternalID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayerSessions = `-- name: GetPlayerSessions :many
SELECT mp.id, mp.player_id, mp.match_id, mp.join_time, mp.leave_time, mp.team, mp.created_at, maps.map_name, m.mode
FROM match_participant mp
JOIN matches m ON mp.match_id = m.id
LEFT JOIN maps ON m.map_id = maps.id
WHERE mp.player_id = ? AND m.server_id = ?
ORDER BY mp.join_time DESC
LIMIT ?
`

type GetPlayerSessionsParams struct {
	PlayerID int64
	ServerID int64
	Limit    int64
}

type GetPlayerSessionsRow struct {
	ID        int64
	PlayerID  int64
	MatchID   int64
	JoinTime  *time.Time
	LeaveTime *time.Time
	Team      *int64
	CreatedAt *time.Time
	MapName   *string
	Mode      string
}

func (q *Queries) GetPlayerSessions(ctx context.Context, arg GetPlayerSessionsParams) ([]GetPlayerSessionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPlayerSessions, arg.PlayerID, arg.ServerID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlayerSessionsRow
	for rows.Next() {
		var i GetPlayerSessionsRow
		if err := rows.Scan(
			&i.ID,
			&i.PlayerID,
			&i.MatchID,
			&i.JoinTime,
			&i.LeaveTime,
			&i.Team,
			&i.CreatedAt,
			&i.MapName,
			&i.Mode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const startSession = `-- name: StartSession :one

INSERT INTO match_participant (player_id, match_id, join_time, team)
VALUES (?, ?, ?, ?)
RETURNING id
`

type StartSessionParams struct {
	PlayerID int64
	MatchID  int64
	JoinTime *time.Time
	Team     *int64
}

// Player session management queries
// simplified: track active players via match_participant entries with null leave_time
func (q *Queries) StartSession(ctx context.Context, arg StartSessionParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, startSession,
		arg.PlayerID,
		arg.MatchID,
		arg.JoinTime,
		arg.Team,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}
