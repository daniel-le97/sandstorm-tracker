// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: match_weapon_stats.sql

package db

import (
	"context"
	"time"
)

const getPlayerTopWeaponsForPeriod = `-- name: GetPlayerTopWeaponsForPeriod :many
SELECT 
    mws.weapon_name,
    SUM(mws.kills) as total_kills,
    SUM(mws.assists) as total_assists,
    COUNT(DISTINCT mws.match_id) as matches_used
FROM match_weapon_stats mws
JOIN matches m ON m.id = mws.match_id
WHERE mws.player_id = ?
  AND m.start_time >= ?
GROUP BY mws.weapon_name
ORDER BY total_kills DESC
LIMIT ?
`

type GetPlayerTopWeaponsForPeriodParams struct {
	PlayerID  int64
	StartTime *time.Time
	Limit     int64
}

type GetPlayerTopWeaponsForPeriodRow struct {
	WeaponName   string
	TotalKills   *float64
	TotalAssists *float64
	MatchesUsed  int64
}

func (q *Queries) GetPlayerTopWeaponsForPeriod(ctx context.Context, arg GetPlayerTopWeaponsForPeriodParams) ([]GetPlayerTopWeaponsForPeriodRow, error) {
	rows, err := q.db.QueryContext(ctx, getPlayerTopWeaponsForPeriod, arg.PlayerID, arg.StartTime, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlayerTopWeaponsForPeriodRow
	for rows.Next() {
		var i GetPlayerTopWeaponsForPeriodRow
		if err := rows.Scan(
			&i.WeaponName,
			&i.TotalKills,
			&i.TotalAssists,
			&i.MatchesUsed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayerWeaponsForMatch = `-- name: GetPlayerWeaponsForMatch :many
SELECT match_id, player_id, weapon_name, kills, assists FROM match_weapon_stats
WHERE match_id = ? AND player_id = ?
ORDER BY kills DESC
`

type GetPlayerWeaponsForMatchParams struct {
	MatchID  int64
	PlayerID int64
}

func (q *Queries) GetPlayerWeaponsForMatch(ctx context.Context, arg GetPlayerWeaponsForMatchParams) ([]MatchWeaponStat, error) {
	rows, err := q.db.QueryContext(ctx, getPlayerWeaponsForMatch, arg.MatchID, arg.PlayerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MatchWeaponStat
	for rows.Next() {
		var i MatchWeaponStat
		if err := rows.Scan(
			&i.MatchID,
			&i.PlayerID,
			&i.WeaponName,
			&i.Kills,
			&i.Assists,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopWeaponsForMatch = `-- name: GetTopWeaponsForMatch :many
SELECT 
    weapon_name,
    SUM(kills) as total_kills,
    SUM(assists) as total_assists,
    COUNT(DISTINCT player_id) as players_used
FROM match_weapon_stats
WHERE match_id = ?
GROUP BY weapon_name
ORDER BY total_kills DESC
LIMIT ?
`

type GetTopWeaponsForMatchParams struct {
	MatchID int64
	Limit   int64
}

type GetTopWeaponsForMatchRow struct {
	WeaponName   string
	TotalKills   *float64
	TotalAssists *float64
	PlayersUsed  int64
}

func (q *Queries) GetTopWeaponsForMatch(ctx context.Context, arg GetTopWeaponsForMatchParams) ([]GetTopWeaponsForMatchRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopWeaponsForMatch, arg.MatchID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopWeaponsForMatchRow
	for rows.Next() {
		var i GetTopWeaponsForMatchRow
		if err := rows.Scan(
			&i.WeaponName,
			&i.TotalKills,
			&i.TotalAssists,
			&i.PlayersUsed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertMatchWeaponStats = `-- name: UpsertMatchWeaponStats :exec
INSERT INTO match_weapon_stats (match_id, player_id, weapon_name, kills, assists)
VALUES (?, ?, ?, ?, ?)
ON CONFLICT(match_id, player_id, weapon_name) DO UPDATE SET
    kills = match_weapon_stats.kills + excluded.kills,
    assists = match_weapon_stats.assists + excluded.assists
`

type UpsertMatchWeaponStatsParams struct {
	MatchID    int64
	PlayerID   int64
	WeaponName string
	Kills      *int64
	Assists    *int64
}

func (q *Queries) UpsertMatchWeaponStats(ctx context.Context, arg UpsertMatchWeaponStatsParams) error {
	_, err := q.db.ExecContext(ctx, upsertMatchWeaponStats,
		arg.MatchID,
		arg.PlayerID,
		arg.WeaponName,
		arg.Kills,
		arg.Assists,
	)
	return err
}
