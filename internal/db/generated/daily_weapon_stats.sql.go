// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: daily_weapon_stats.sql

package db

import (
	"context"
	"time"
)

const deleteOldDailyWeaponStats = `-- name: DeleteOldDailyWeaponStats :exec
DELETE FROM daily_weapon_stats WHERE date < ?
`

func (q *Queries) DeleteOldDailyWeaponStats(ctx context.Context, date time.Time) error {
	_, err := q.db.ExecContext(ctx, deleteOldDailyWeaponStats, date)
	return err
}

const getTopWeaponsForPlayerForPeriod = `-- name: GetTopWeaponsForPlayerForPeriod :many
SELECT 
    weapon_name,
    CAST(COALESCE(SUM(kills), 0) AS INTEGER) as total_kills,
    CAST(COALESCE(SUM(assists), 0) AS INTEGER) as total_assists
FROM daily_weapon_stats
WHERE player_id = ?
  AND server_id = ?
  AND date >= ?
GROUP BY weapon_name
HAVING total_kills > 0
ORDER BY total_kills DESC
LIMIT ?
`

type GetTopWeaponsForPlayerForPeriodParams struct {
	PlayerID int64
	ServerID int64
	Date     time.Time
	Limit    int64
}

type GetTopWeaponsForPlayerForPeriodRow struct {
	WeaponName   string
	TotalKills   int64
	TotalAssists int64
}

func (q *Queries) GetTopWeaponsForPlayerForPeriod(ctx context.Context, arg GetTopWeaponsForPlayerForPeriodParams) ([]GetTopWeaponsForPlayerForPeriodRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopWeaponsForPlayerForPeriod,
		arg.PlayerID,
		arg.ServerID,
		arg.Date,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopWeaponsForPlayerForPeriodRow
	for rows.Next() {
		var i GetTopWeaponsForPlayerForPeriodRow
		if err := rows.Scan(&i.WeaponName, &i.TotalKills, &i.TotalAssists); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWeaponStatsForPlayerForPeriod = `-- name: GetWeaponStatsForPlayerForPeriod :many
SELECT 
    weapon_name,
    CAST(COALESCE(SUM(kills), 0) AS INTEGER) as total_kills,
    CAST(COALESCE(SUM(assists), 0) AS INTEGER) as total_assists
FROM daily_weapon_stats
WHERE player_id = ?
  AND server_id = ?
  AND date >= ?
GROUP BY weapon_name
`

type GetWeaponStatsForPlayerForPeriodParams struct {
	PlayerID int64
	ServerID int64
	Date     time.Time
}

type GetWeaponStatsForPlayerForPeriodRow struct {
	WeaponName   string
	TotalKills   int64
	TotalAssists int64
}

func (q *Queries) GetWeaponStatsForPlayerForPeriod(ctx context.Context, arg GetWeaponStatsForPlayerForPeriodParams) ([]GetWeaponStatsForPlayerForPeriodRow, error) {
	rows, err := q.db.QueryContext(ctx, getWeaponStatsForPlayerForPeriod, arg.PlayerID, arg.ServerID, arg.Date)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWeaponStatsForPlayerForPeriodRow
	for rows.Next() {
		var i GetWeaponStatsForPlayerForPeriodRow
		if err := rows.Scan(&i.WeaponName, &i.TotalKills, &i.TotalAssists); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertDailyWeaponStats = `-- name: UpsertDailyWeaponStats :one
INSERT INTO daily_weapon_stats (player_id, server_id, date, weapon_name, kills, assists)
VALUES (?, ?, ?, ?, ?, ?)
ON CONFLICT(player_id, server_id, date, weapon_name) DO UPDATE SET
    kills = daily_weapon_stats.kills + excluded.kills,
    assists = daily_weapon_stats.assists + excluded.assists
RETURNING player_id, server_id, date, weapon_name, kills, assists
`

type UpsertDailyWeaponStatsParams struct {
	PlayerID   int64
	ServerID   int64
	Date       time.Time
	WeaponName string
	Kills      *int64
	Assists    *int64
}

func (q *Queries) UpsertDailyWeaponStats(ctx context.Context, arg UpsertDailyWeaponStatsParams) (DailyWeaponStat, error) {
	row := q.db.QueryRowContext(ctx, upsertDailyWeaponStats,
		arg.PlayerID,
		arg.ServerID,
		arg.Date,
		arg.WeaponName,
		arg.Kills,
		arg.Assists,
	)
	var i DailyWeaponStat
	err := row.Scan(
		&i.PlayerID,
		&i.ServerID,
		&i.Date,
		&i.WeaponName,
		&i.Kills,
		&i.Assists,
	)
	return i, err
}
