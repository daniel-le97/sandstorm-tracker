// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: match_player_stats.sql

package db

import (
	"context"
	"time"
)

const disconnectAllPlayersInMatch = `-- name: DisconnectAllPlayersInMatch :exec
UPDATE match_player_stats
SET 
    is_currently_connected = 0,
    last_left_at = COALESCE(last_left_at, ?),
    updated_at = CURRENT_TIMESTAMP
WHERE match_id = ? AND is_currently_connected = 1
`

type DisconnectAllPlayersInMatchParams struct {
	LastLeftAt *time.Time
	MatchID    int64
}

func (q *Queries) DisconnectAllPlayersInMatch(ctx context.Context, arg DisconnectAllPlayersInMatchParams) error {
	_, err := q.db.ExecContext(ctx, disconnectAllPlayersInMatch, arg.LastLeftAt, arg.MatchID)
	return err
}

const getAllPlayersInMatch = `-- name: GetAllPlayersInMatch :many
SELECT 
    mps.match_id, mps.player_id, mps.team, mps.kills, mps.assists, mps.deaths, mps.friendly_fire_kills, mps.score, mps.objectives_captured, mps.objectives_destroyed, mps.total_play_time, mps.session_count, mps.first_joined_at, mps.last_left_at, mps.is_currently_connected, mps.created_at, mps.updated_at,
    p.name as player_name,
    p.external_id as player_external_id
FROM match_player_stats mps
JOIN players p ON p.id = mps.player_id
WHERE mps.match_id = ?
ORDER BY mps.score DESC
`

type GetAllPlayersInMatchRow struct {
	MatchID              int64
	PlayerID             int64
	Team                 *int64
	Kills                *int64
	Assists              *int64
	Deaths               *int64
	FriendlyFireKills    *int64
	Score                *int64
	ObjectivesCaptured   *int64
	ObjectivesDestroyed  *int64
	TotalPlayTime        *int64
	SessionCount         *int64
	FirstJoinedAt        *time.Time
	LastLeftAt           *time.Time
	IsCurrentlyConnected *int64
	CreatedAt            *time.Time
	UpdatedAt            *time.Time
	PlayerName           string
	PlayerExternalID     string
}

func (q *Queries) GetAllPlayersInMatch(ctx context.Context, matchID int64) ([]GetAllPlayersInMatchRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllPlayersInMatch, matchID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllPlayersInMatchRow
	for rows.Next() {
		var i GetAllPlayersInMatchRow
		if err := rows.Scan(
			&i.MatchID,
			&i.PlayerID,
			&i.Team,
			&i.Kills,
			&i.Assists,
			&i.Deaths,
			&i.FriendlyFireKills,
			&i.Score,
			&i.ObjectivesCaptured,
			&i.ObjectivesDestroyed,
			&i.TotalPlayTime,
			&i.SessionCount,
			&i.FirstJoinedAt,
			&i.LastLeftAt,
			&i.IsCurrentlyConnected,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PlayerName,
			&i.PlayerExternalID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCurrentlyConnectedPlayers = `-- name: GetCurrentlyConnectedPlayers :many
SELECT 
    mps.match_id, mps.player_id, mps.team, mps.kills, mps.assists, mps.deaths, mps.friendly_fire_kills, mps.score, mps.objectives_captured, mps.objectives_destroyed, mps.total_play_time, mps.session_count, mps.first_joined_at, mps.last_left_at, mps.is_currently_connected, mps.created_at, mps.updated_at,
    p.name,
    p.external_id
FROM match_player_stats mps
JOIN players p ON p.id = mps.player_id
WHERE mps.match_id = ? 
  AND mps.is_currently_connected = 1
`

type GetCurrentlyConnectedPlayersRow struct {
	MatchID              int64
	PlayerID             int64
	Team                 *int64
	Kills                *int64
	Assists              *int64
	Deaths               *int64
	FriendlyFireKills    *int64
	Score                *int64
	ObjectivesCaptured   *int64
	ObjectivesDestroyed  *int64
	TotalPlayTime        *int64
	SessionCount         *int64
	FirstJoinedAt        *time.Time
	LastLeftAt           *time.Time
	IsCurrentlyConnected *int64
	CreatedAt            *time.Time
	UpdatedAt            *time.Time
	Name                 string
	ExternalID           string
}

func (q *Queries) GetCurrentlyConnectedPlayers(ctx context.Context, matchID int64) ([]GetCurrentlyConnectedPlayersRow, error) {
	rows, err := q.db.QueryContext(ctx, getCurrentlyConnectedPlayers, matchID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCurrentlyConnectedPlayersRow
	for rows.Next() {
		var i GetCurrentlyConnectedPlayersRow
		if err := rows.Scan(
			&i.MatchID,
			&i.PlayerID,
			&i.Team,
			&i.Kills,
			&i.Assists,
			&i.Deaths,
			&i.FriendlyFireKills,
			&i.Score,
			&i.ObjectivesCaptured,
			&i.ObjectivesDestroyed,
			&i.TotalPlayTime,
			&i.SessionCount,
			&i.FirstJoinedAt,
			&i.LastLeftAt,
			&i.IsCurrentlyConnected,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.ExternalID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMatchPlayerStats = `-- name: GetMatchPlayerStats :one
SELECT match_id, player_id, team, kills, assists, deaths, friendly_fire_kills, score, objectives_captured, objectives_destroyed, total_play_time, session_count, first_joined_at, last_left_at, is_currently_connected, created_at, updated_at FROM match_player_stats
WHERE match_id = ? AND player_id = ?
`

type GetMatchPlayerStatsParams struct {
	MatchID  int64
	PlayerID int64
}

func (q *Queries) GetMatchPlayerStats(ctx context.Context, arg GetMatchPlayerStatsParams) (MatchPlayerStat, error) {
	row := q.db.QueryRowContext(ctx, getMatchPlayerStats, arg.MatchID, arg.PlayerID)
	var i MatchPlayerStat
	err := row.Scan(
		&i.MatchID,
		&i.PlayerID,
		&i.Team,
		&i.Kills,
		&i.Assists,
		&i.Deaths,
		&i.FriendlyFireKills,
		&i.Score,
		&i.ObjectivesCaptured,
		&i.ObjectivesDestroyed,
		&i.TotalPlayTime,
		&i.SessionCount,
		&i.FirstJoinedAt,
		&i.LastLeftAt,
		&i.IsCurrentlyConnected,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPlayerBestMatch = `-- name: GetPlayerBestMatch :one
SELECT 
    mps.match_id, mps.player_id, mps.team, mps.kills, mps.assists, mps.deaths, mps.friendly_fire_kills, mps.score, mps.objectives_captured, mps.objectives_destroyed, mps.total_play_time, mps.session_count, mps.first_joined_at, mps.last_left_at, mps.is_currently_connected, mps.created_at, mps.updated_at,
    m.map,
    m.mode,
    m.start_time
FROM match_player_stats mps
JOIN matches m ON m.id = mps.match_id
WHERE mps.player_id = ?
ORDER BY mps.kills DESC
LIMIT 1
`

type GetPlayerBestMatchRow struct {
	MatchID              int64
	PlayerID             int64
	Team                 *int64
	Kills                *int64
	Assists              *int64
	Deaths               *int64
	FriendlyFireKills    *int64
	Score                *int64
	ObjectivesCaptured   *int64
	ObjectivesDestroyed  *int64
	TotalPlayTime        *int64
	SessionCount         *int64
	FirstJoinedAt        *time.Time
	LastLeftAt           *time.Time
	IsCurrentlyConnected *int64
	CreatedAt            *time.Time
	UpdatedAt            *time.Time
	Map                  *string
	Mode                 string
	StartTime            *time.Time
}

func (q *Queries) GetPlayerBestMatch(ctx context.Context, playerID int64) (GetPlayerBestMatchRow, error) {
	row := q.db.QueryRowContext(ctx, getPlayerBestMatch, playerID)
	var i GetPlayerBestMatchRow
	err := row.Scan(
		&i.MatchID,
		&i.PlayerID,
		&i.Team,
		&i.Kills,
		&i.Assists,
		&i.Deaths,
		&i.FriendlyFireKills,
		&i.Score,
		&i.ObjectivesCaptured,
		&i.ObjectivesDestroyed,
		&i.TotalPlayTime,
		&i.SessionCount,
		&i.FirstJoinedAt,
		&i.LastLeftAt,
		&i.IsCurrentlyConnected,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Map,
		&i.Mode,
		&i.StartTime,
	)
	return i, err
}

const getPlayerMatchHistory = `-- name: GetPlayerMatchHistory :many
SELECT 
    mps.match_id, mps.player_id, mps.team, mps.kills, mps.assists, mps.deaths, mps.friendly_fire_kills, mps.score, mps.objectives_captured, mps.objectives_destroyed, mps.total_play_time, mps.session_count, mps.first_joined_at, mps.last_left_at, mps.is_currently_connected, mps.created_at, mps.updated_at,
    m.map,
    m.mode,
    m.start_time,
    m.end_time,
    m.winner_team
FROM match_player_stats mps
JOIN matches m ON m.id = mps.match_id
WHERE mps.player_id = ?
ORDER BY m.start_time DESC
LIMIT ?
`

type GetPlayerMatchHistoryParams struct {
	PlayerID int64
	Limit    int64
}

type GetPlayerMatchHistoryRow struct {
	MatchID              int64
	PlayerID             int64
	Team                 *int64
	Kills                *int64
	Assists              *int64
	Deaths               *int64
	FriendlyFireKills    *int64
	Score                *int64
	ObjectivesCaptured   *int64
	ObjectivesDestroyed  *int64
	TotalPlayTime        *int64
	SessionCount         *int64
	FirstJoinedAt        *time.Time
	LastLeftAt           *time.Time
	IsCurrentlyConnected *int64
	CreatedAt            *time.Time
	UpdatedAt            *time.Time
	Map                  *string
	Mode                 string
	StartTime            *time.Time
	EndTime              *time.Time
	WinnerTeam           *int64
}

func (q *Queries) GetPlayerMatchHistory(ctx context.Context, arg GetPlayerMatchHistoryParams) ([]GetPlayerMatchHistoryRow, error) {
	rows, err := q.db.QueryContext(ctx, getPlayerMatchHistory, arg.PlayerID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlayerMatchHistoryRow
	for rows.Next() {
		var i GetPlayerMatchHistoryRow
		if err := rows.Scan(
			&i.MatchID,
			&i.PlayerID,
			&i.Team,
			&i.Kills,
			&i.Assists,
			&i.Deaths,
			&i.FriendlyFireKills,
			&i.Score,
			&i.ObjectivesCaptured,
			&i.ObjectivesDestroyed,
			&i.TotalPlayTime,
			&i.SessionCount,
			&i.FirstJoinedAt,
			&i.LastLeftAt,
			&i.IsCurrentlyConnected,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Map,
			&i.Mode,
			&i.StartTime,
			&i.EndTime,
			&i.WinnerTeam,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayerStatsForPeriod = `-- name: GetPlayerStatsForPeriod :one
SELECT 
    COUNT(DISTINCT mps.match_id) as total_matches,
    SUM(mps.kills) as total_kills,
    SUM(mps.assists) as total_assists,
    SUM(mps.deaths) as total_deaths,
    SUM(mps.score) as total_score,
    SUM(mps.total_play_time) as total_play_time,
    SUM(mps.session_count) as total_sessions
FROM match_player_stats mps
JOIN matches m ON m.id = mps.match_id
WHERE mps.player_id = ? 
  AND m.server_id = ?
  AND m.start_time >= ?
`

type GetPlayerStatsForPeriodParams struct {
	PlayerID  int64
	ServerID  int64
	StartTime *time.Time
}

type GetPlayerStatsForPeriodRow struct {
	TotalMatches  int64
	TotalKills    *float64
	TotalAssists  *float64
	TotalDeaths   *float64
	TotalScore    *float64
	TotalPlayTime *float64
	TotalSessions *float64
}

func (q *Queries) GetPlayerStatsForPeriod(ctx context.Context, arg GetPlayerStatsForPeriodParams) (GetPlayerStatsForPeriodRow, error) {
	row := q.db.QueryRowContext(ctx, getPlayerStatsForPeriod, arg.PlayerID, arg.ServerID, arg.StartTime)
	var i GetPlayerStatsForPeriodRow
	err := row.Scan(
		&i.TotalMatches,
		&i.TotalKills,
		&i.TotalAssists,
		&i.TotalDeaths,
		&i.TotalScore,
		&i.TotalPlayTime,
		&i.TotalSessions,
	)
	return i, err
}

const getStaleConnections = `-- name: GetStaleConnections :many
SELECT mps.match_id, mps.player_id, mps.team, mps.kills, mps.assists, mps.deaths, mps.friendly_fire_kills, mps.score, mps.objectives_captured, mps.objectives_destroyed, mps.total_play_time, mps.session_count, mps.first_joined_at, mps.last_left_at, mps.is_currently_connected, mps.created_at, mps.updated_at, m.end_time
FROM match_player_stats mps
JOIN matches m ON m.id = mps.match_id
WHERE mps.is_currently_connected = 1
  AND m.end_time IS NOT NULL
`

type GetStaleConnectionsRow struct {
	MatchID              int64
	PlayerID             int64
	Team                 *int64
	Kills                *int64
	Assists              *int64
	Deaths               *int64
	FriendlyFireKills    *int64
	Score                *int64
	ObjectivesCaptured   *int64
	ObjectivesDestroyed  *int64
	TotalPlayTime        *int64
	SessionCount         *int64
	FirstJoinedAt        *time.Time
	LastLeftAt           *time.Time
	IsCurrentlyConnected *int64
	CreatedAt            *time.Time
	UpdatedAt            *time.Time
	EndTime              *time.Time
}

// Find players still marked as connected in matches that ended
func (q *Queries) GetStaleConnections(ctx context.Context) ([]GetStaleConnectionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getStaleConnections)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStaleConnectionsRow
	for rows.Next() {
		var i GetStaleConnectionsRow
		if err := rows.Scan(
			&i.MatchID,
			&i.PlayerID,
			&i.Team,
			&i.Kills,
			&i.Assists,
			&i.Deaths,
			&i.FriendlyFireKills,
			&i.Score,
			&i.ObjectivesCaptured,
			&i.ObjectivesDestroyed,
			&i.TotalPlayTime,
			&i.SessionCount,
			&i.FirstJoinedAt,
			&i.LastLeftAt,
			&i.IsCurrentlyConnected,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.EndTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopPlayersByKillsForPeriod = `-- name: GetTopPlayersByKillsForPeriod :many
SELECT 
    p.id,
    p.name,
    p.external_id,
    SUM(mps.kills) as total_kills,
    SUM(mps.deaths) as total_deaths,
    SUM(mps.assists) as total_assists,
    COUNT(DISTINCT mps.match_id) as matches_played
FROM match_player_stats mps
JOIN players p ON p.id = mps.player_id
JOIN matches m ON m.id = mps.match_id
WHERE m.server_id = ?
  AND m.start_time >= ?
GROUP BY p.id, p.name, p.external_id
ORDER BY total_kills DESC
LIMIT ?
`

type GetTopPlayersByKillsForPeriodParams struct {
	ServerID  int64
	StartTime *time.Time
	Limit     int64
}

type GetTopPlayersByKillsForPeriodRow struct {
	ID            int64
	Name          string
	ExternalID    string
	TotalKills    *float64
	TotalDeaths   *float64
	TotalAssists  *float64
	MatchesPlayed int64
}

func (q *Queries) GetTopPlayersByKillsForPeriod(ctx context.Context, arg GetTopPlayersByKillsForPeriodParams) ([]GetTopPlayersByKillsForPeriodRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopPlayersByKillsForPeriod, arg.ServerID, arg.StartTime, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopPlayersByKillsForPeriodRow
	for rows.Next() {
		var i GetTopPlayersByKillsForPeriodRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ExternalID,
			&i.TotalKills,
			&i.TotalDeaths,
			&i.TotalAssists,
			&i.MatchesPlayed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementMatchPlayerAssists = `-- name: IncrementMatchPlayerAssists :exec
UPDATE match_player_stats
SET 
    assists = assists + 1,
    updated_at = CURRENT_TIMESTAMP
WHERE match_id = ? AND player_id = ?
`

type IncrementMatchPlayerAssistsParams struct {
	MatchID  int64
	PlayerID int64
}

func (q *Queries) IncrementMatchPlayerAssists(ctx context.Context, arg IncrementMatchPlayerAssistsParams) error {
	_, err := q.db.ExecContext(ctx, incrementMatchPlayerAssists, arg.MatchID, arg.PlayerID)
	return err
}

const incrementMatchPlayerDeaths = `-- name: IncrementMatchPlayerDeaths :exec
UPDATE match_player_stats
SET 
    deaths = deaths + 1,
    updated_at = CURRENT_TIMESTAMP
WHERE match_id = ? AND player_id = ?
`

type IncrementMatchPlayerDeathsParams struct {
	MatchID  int64
	PlayerID int64
}

func (q *Queries) IncrementMatchPlayerDeaths(ctx context.Context, arg IncrementMatchPlayerDeathsParams) error {
	_, err := q.db.ExecContext(ctx, incrementMatchPlayerDeaths, arg.MatchID, arg.PlayerID)
	return err
}

const incrementMatchPlayerFFKills = `-- name: IncrementMatchPlayerFFKills :exec
UPDATE match_player_stats
SET 
    friendly_fire_kills = friendly_fire_kills + 1,
    updated_at = CURRENT_TIMESTAMP
WHERE match_id = ? AND player_id = ?
`

type IncrementMatchPlayerFFKillsParams struct {
	MatchID  int64
	PlayerID int64
}

func (q *Queries) IncrementMatchPlayerFFKills(ctx context.Context, arg IncrementMatchPlayerFFKillsParams) error {
	_, err := q.db.ExecContext(ctx, incrementMatchPlayerFFKills, arg.MatchID, arg.PlayerID)
	return err
}

const incrementMatchPlayerKills = `-- name: IncrementMatchPlayerKills :exec
UPDATE match_player_stats
SET 
    kills = kills + 1,
    updated_at = CURRENT_TIMESTAMP
WHERE match_id = ? AND player_id = ?
`

type IncrementMatchPlayerKillsParams struct {
	MatchID  int64
	PlayerID int64
}

func (q *Queries) IncrementMatchPlayerKills(ctx context.Context, arg IncrementMatchPlayerKillsParams) error {
	_, err := q.db.ExecContext(ctx, incrementMatchPlayerKills, arg.MatchID, arg.PlayerID)
	return err
}

const incrementMatchPlayerObjectiveCaptured = `-- name: IncrementMatchPlayerObjectiveCaptured :exec
UPDATE match_player_stats
SET 
    objectives_captured = objectives_captured + 1,
    updated_at = CURRENT_TIMESTAMP
WHERE match_id = ? AND player_id = ?
`

type IncrementMatchPlayerObjectiveCapturedParams struct {
	MatchID  int64
	PlayerID int64
}

func (q *Queries) IncrementMatchPlayerObjectiveCaptured(ctx context.Context, arg IncrementMatchPlayerObjectiveCapturedParams) error {
	_, err := q.db.ExecContext(ctx, incrementMatchPlayerObjectiveCaptured, arg.MatchID, arg.PlayerID)
	return err
}

const incrementMatchPlayerObjectiveDestroyed = `-- name: IncrementMatchPlayerObjectiveDestroyed :exec
UPDATE match_player_stats
SET 
    objectives_destroyed = objectives_destroyed + 1,
    updated_at = CURRENT_TIMESTAMP
WHERE match_id = ? AND player_id = ?
`

type IncrementMatchPlayerObjectiveDestroyedParams struct {
	MatchID  int64
	PlayerID int64
}

func (q *Queries) IncrementMatchPlayerObjectiveDestroyed(ctx context.Context, arg IncrementMatchPlayerObjectiveDestroyedParams) error {
	_, err := q.db.ExecContext(ctx, incrementMatchPlayerObjectiveDestroyed, arg.MatchID, arg.PlayerID)
	return err
}

const updateMatchPlayerDisconnect = `-- name: UpdateMatchPlayerDisconnect :exec
UPDATE match_player_stats
SET 
    is_currently_connected = 0,
    last_left_at = ?,
    total_play_time = total_play_time + ?,
    updated_at = CURRENT_TIMESTAMP
WHERE match_id = ? AND player_id = ?
`

type UpdateMatchPlayerDisconnectParams struct {
	LastLeftAt    *time.Time
	TotalPlayTime *int64
	MatchID       int64
	PlayerID      int64
}

func (q *Queries) UpdateMatchPlayerDisconnect(ctx context.Context, arg UpdateMatchPlayerDisconnectParams) error {
	_, err := q.db.ExecContext(ctx, updateMatchPlayerDisconnect,
		arg.LastLeftAt,
		arg.TotalPlayTime,
		arg.MatchID,
		arg.PlayerID,
	)
	return err
}

const updateMatchPlayerScore = `-- name: UpdateMatchPlayerScore :exec
UPDATE match_player_stats
SET 
    score = score + ?,
    updated_at = CURRENT_TIMESTAMP
WHERE match_id = ? AND player_id = ?
`

type UpdateMatchPlayerScoreParams struct {
	Score    *int64
	MatchID  int64
	PlayerID int64
}

func (q *Queries) UpdateMatchPlayerScore(ctx context.Context, arg UpdateMatchPlayerScoreParams) error {
	_, err := q.db.ExecContext(ctx, updateMatchPlayerScore, arg.Score, arg.MatchID, arg.PlayerID)
	return err
}

const upsertMatchPlayerStats = `-- name: UpsertMatchPlayerStats :exec
INSERT INTO match_player_stats (
    match_id, player_id, team, first_joined_at, session_count, is_currently_connected
)
VALUES (?, ?, ?, ?, 1, 1)
ON CONFLICT(match_id, player_id) DO UPDATE SET
    session_count = session_count + 1,
    is_currently_connected = 1,
    updated_at = CURRENT_TIMESTAMP
`

type UpsertMatchPlayerStatsParams struct {
	MatchID       int64
	PlayerID      int64
	Team          *int64
	FirstJoinedAt *time.Time
}

func (q *Queries) UpsertMatchPlayerStats(ctx context.Context, arg UpsertMatchPlayerStatsParams) error {
	_, err := q.db.ExecContext(ctx, upsertMatchPlayerStats,
		arg.MatchID,
		arg.PlayerID,
		arg.Team,
		arg.FirstJoinedAt,
	)
	return err
}
