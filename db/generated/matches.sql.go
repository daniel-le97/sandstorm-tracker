// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: matches.sql

package db

import (
	"context"
	"time"
)

const abortMatch = `-- name: AbortMatch :exec
UPDATE matches
SET end_time = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ? AND server_id = ?
`

type AbortMatchParams struct {
	EndTime  *time.Time
	ID       int64
	ServerID int64
}

func (q *Queries) AbortMatch(ctx context.Context, arg AbortMatchParams) error {
	_, err := q.db.ExecContext(ctx, abortMatch, arg.EndTime, arg.ID, arg.ServerID)
	return err
}

const endMatch = `-- name: EndMatch :exec
UPDATE matches
SET end_time = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ? AND server_id = ?
`

type EndMatchParams struct {
	EndTime  *time.Time
	ID       int64
	ServerID int64
}

func (q *Queries) EndMatch(ctx context.Context, arg EndMatchParams) error {
	_, err := q.db.ExecContext(ctx, endMatch, arg.EndTime, arg.ID, arg.ServerID)
	return err
}

const getActiveMatches = `-- name: GetActiveMatches :many
SELECT id, server_id, map, mode, winner_team, start_time, end_time, created_at, updated_at FROM matches
WHERE server_id = ? AND end_time IS NULL
ORDER BY start_time DESC
`

func (q *Queries) GetActiveMatches(ctx context.Context, serverID int64) ([]Match, error) {
	rows, err := q.db.QueryContext(ctx, getActiveMatches, serverID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Match
	for rows.Next() {
		var i Match
		if err := rows.Scan(
			&i.ID,
			&i.ServerID,
			&i.Map,
			&i.Mode,
			&i.WinnerTeam,
			&i.StartTime,
			&i.EndTime,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMatchDetails = `-- name: GetMatchDetails :one
SELECT
    m.id, m.server_id, m.map, m.mode, m.winner_team, m.start_time, m.end_time, m.created_at, m.updated_at,
    (SELECT COUNT(*) FROM match_participant WHERE match_id = m.id) as participant_count
FROM matches m
WHERE m.id = ? AND m.server_id = ?
`

type GetMatchDetailsParams struct {
	ID       int64
	ServerID int64
}

type GetMatchDetailsRow struct {
	ID               int64
	ServerID         int64
	Map              *string
	Mode             *string
	WinnerTeam       *int64
	StartTime        *time.Time
	EndTime          *time.Time
	CreatedAt        *time.Time
	UpdatedAt        *time.Time
	ParticipantCount int64
}

func (q *Queries) GetMatchDetails(ctx context.Context, arg GetMatchDetailsParams) (GetMatchDetailsRow, error) {
	row := q.db.QueryRowContext(ctx, getMatchDetails, arg.ID, arg.ServerID)
	var i GetMatchDetailsRow
	err := row.Scan(
		&i.ID,
		&i.ServerID,
		&i.Map,
		&i.Mode,
		&i.WinnerTeam,
		&i.StartTime,
		&i.EndTime,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ParticipantCount,
	)
	return i, err
}

const getMatchHistory = `-- name: GetMatchHistory :many
SELECT
    m.id, m.server_id, m.map, m.mode, m.winner_team, m.start_time, m.end_time, m.created_at, m.updated_at,
    COUNT(DISTINCT mp.player_id) as participant_count
FROM matches m
LEFT JOIN match_participant mp ON m.id = mp.match_id
WHERE m.server_id = ?
GROUP BY m.id
ORDER BY m.start_time DESC
LIMIT ?
`

type GetMatchHistoryParams struct {
	ServerID int64
	Limit    int64
}

type GetMatchHistoryRow struct {
	ID               int64
	ServerID         int64
	Map              *string
	Mode             *string
	WinnerTeam       *int64
	StartTime        *time.Time
	EndTime          *time.Time
	CreatedAt        *time.Time
	UpdatedAt        *time.Time
	ParticipantCount int64
}

func (q *Queries) GetMatchHistory(ctx context.Context, arg GetMatchHistoryParams) ([]GetMatchHistoryRow, error) {
	rows, err := q.db.QueryContext(ctx, getMatchHistory, arg.ServerID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMatchHistoryRow
	for rows.Next() {
		var i GetMatchHistoryRow
		if err := rows.Scan(
			&i.ID,
			&i.ServerID,
			&i.Map,
			&i.Mode,
			&i.WinnerTeam,
			&i.StartTime,
			&i.EndTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParticipantCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const startMatch = `-- name: StartMatch :one

INSERT INTO matches (server_id, map, mode, start_time)
VALUES (?, ?, ?, ?)
RETURNING id
`

type StartMatchParams struct {
	ServerID  int64
	Map       *string
	Mode      *string
	StartTime *time.Time
}

// Match management queries
func (q *Queries) StartMatch(ctx context.Context, arg StartMatchParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, startMatch,
		arg.ServerID,
		arg.Map,
		arg.Mode,
		arg.StartTime,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updateMatchPlayerCount = `-- name: UpdateMatchPlayerCount :exec
UPDATE matches
SET updated_at = CURRENT_TIMESTAMP
WHERE id = ? AND server_id = ?
`

type UpdateMatchPlayerCountParams struct {
	ID       int64
	ServerID int64
}

// simplified schema does not track counts here; placeholder
func (q *Queries) UpdateMatchPlayerCount(ctx context.Context, arg UpdateMatchPlayerCountParams) error {
	_, err := q.db.ExecContext(ctx, updateMatchPlayerCount, arg.ID, arg.ServerID)
	return err
}
