// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: weapon_stats.sql

package db

import (
	"context"
)

const getPlayerWeaponStats = `-- name: GetPlayerWeaponStats :many
SELECT 
    weapon_name,
    SUM(kills) as kills,
    SUM(deaths) as deaths,
    SUM(team_kills) as team_kills,
    SUM(suicides) as suicides
FROM weapon_stats
WHERE player_id = ? AND server_id = ?
GROUP BY weapon_name
ORDER BY kills DESC
LIMIT ?
`

type GetPlayerWeaponStatsParams struct {
	PlayerID int64
	ServerID int64
	Limit    int64
}

type GetPlayerWeaponStatsRow struct {
	WeaponName string
	Kills      *float64
	Deaths     *float64
	TeamKills  *float64
	Suicides   *float64
}

func (q *Queries) GetPlayerWeaponStats(ctx context.Context, arg GetPlayerWeaponStatsParams) ([]GetPlayerWeaponStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPlayerWeaponStats, arg.PlayerID, arg.ServerID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlayerWeaponStatsRow
	for rows.Next() {
		var i GetPlayerWeaponStatsRow
		if err := rows.Scan(
			&i.WeaponName,
			&i.Kills,
			&i.Deaths,
			&i.TeamKills,
			&i.Suicides,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopWeapons = `-- name: GetTopWeapons :many
SELECT 
    weapon_name,
    SUM(kills) as total_kills,
    COUNT(DISTINCT player_id) as players_used
FROM weapon_stats
WHERE server_id = ?
GROUP BY weapon_name
ORDER BY total_kills DESC
LIMIT ?
`

type GetTopWeaponsParams struct {
	ServerID int64
	Limit    int64
}

type GetTopWeaponsRow struct {
	WeaponName  string
	TotalKills  *float64
	PlayersUsed int64
}

func (q *Queries) GetTopWeapons(ctx context.Context, arg GetTopWeaponsParams) ([]GetTopWeaponsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopWeapons, arg.ServerID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopWeaponsRow
	for rows.Next() {
		var i GetTopWeaponsRow
		if err := rows.Scan(&i.WeaponName, &i.TotalKills, &i.PlayersUsed); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertWeaponStats = `-- name: UpsertWeaponStats :exec

INSERT INTO weapon_stats (player_id, server_id, weapon_name, kills, deaths, team_kills, suicides)
VALUES (?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(player_id, weapon_name, server_id) DO UPDATE SET
    kills = kills + excluded.kills,
    deaths = deaths + excluded.deaths,
    team_kills = team_kills + excluded.team_kills,
    suicides = suicides + excluded.suicides,
    updated_at = CURRENT_TIMESTAMP
`

type UpsertWeaponStatsParams struct {
	PlayerID   int64
	ServerID   int64
	WeaponName string
	Kills      *int64
	Deaths     *int64
	TeamKills  *int64
	Suicides   *int64
}

// Weapon statistics queries
func (q *Queries) UpsertWeaponStats(ctx context.Context, arg UpsertWeaponStatsParams) error {
	_, err := q.db.ExecContext(ctx, upsertWeaponStats,
		arg.PlayerID,
		arg.ServerID,
		arg.WeaponName,
		arg.Kills,
		arg.Deaths,
		arg.TeamKills,
		arg.Suicides,
	)
	return err
}
