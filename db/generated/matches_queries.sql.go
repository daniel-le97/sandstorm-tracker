// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: matches_queries.sql

package db

import (
	"context"
	"time"
)

const addMatchMap = `-- name: AddMatchMap :one
INSERT INTO maps (map_name, scenario)
VALUES (?, ?)
ON CONFLICT(map_name) DO UPDATE SET
    scenario = excluded.scenario
RETURNING id
`

type AddMatchMapParams struct {
	MapName  string
	Scenario *string
}

// match maps not used in simplified schema; keep placeholder
func (q *Queries) AddMatchMap(ctx context.Context, arg AddMatchMapParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, addMatchMap, arg.MapName, arg.Scenario)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const addMatchParticipant = `-- name: AddMatchParticipant :one

INSERT INTO match_participant (match_id, player_id, join_time, team)
VALUES (?, ?, ?, ?)
ON CONFLICT(match_id, player_id) DO UPDATE SET
    join_time = excluded.join_time,
    team = excluded.team
RETURNING id
`

type AddMatchParticipantParams struct {
	MatchID  int64
	PlayerID int64
	JoinTime *time.Time
	Team     *int64
}

// Match participant and map queries
func (q *Queries) AddMatchParticipant(ctx context.Context, arg AddMatchParticipantParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, addMatchParticipant,
		arg.MatchID,
		arg.PlayerID,
		arg.JoinTime,
		arg.Team,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const endMatchMap = `-- name: EndMatchMap :exec
UPDATE maps SET updated_at = CURRENT_TIMESTAMP WHERE id = ?
`

func (q *Queries) EndMatchMap(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, endMatchMap, id)
	return err
}

const endMatchParticipant = `-- name: EndMatchParticipant :exec
UPDATE match_participant
SET leave_time = ?, team = ?
WHERE match_id = ? AND player_id = ?
`

type EndMatchParticipantParams struct {
	LeaveTime *time.Time
	Team      *int64
	MatchID   int64
	PlayerID  int64
}

func (q *Queries) EndMatchParticipant(ctx context.Context, arg EndMatchParticipantParams) error {
	_, err := q.db.ExecContext(ctx, endMatchParticipant,
		arg.LeaveTime,
		arg.Team,
		arg.MatchID,
		arg.PlayerID,
	)
	return err
}

const getMatchMaps = `-- name: GetMatchMaps :many
SELECT id, map_name, scenario FROM maps WHERE 0=1
`

type GetMatchMapsRow struct {
	ID       int64
	MapName  string
	Scenario *string
}

// match_maps no longer present in simplified schema; return empty set (placeholder)
func (q *Queries) GetMatchMaps(ctx context.Context) ([]GetMatchMapsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMatchMaps)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMatchMapsRow
	for rows.Next() {
		var i GetMatchMapsRow
		if err := rows.Scan(&i.ID, &i.MapName, &i.Scenario); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMatchParticipants = `-- name: GetMatchParticipants :many
SELECT
    mp.id, mp.player_id, mp.match_id, mp.join_time, mp.leave_time, mp.team, mp.created_at,
    p.name as player_name,
    p.external_id as external_id
FROM match_participant mp
JOIN players p ON mp.player_id = p.id
WHERE mp.match_id = ?
ORDER BY mp.join_time ASC
`

type GetMatchParticipantsRow struct {
	ID         int64
	PlayerID   int64
	MatchID    int64
	JoinTime   *time.Time
	LeaveTime  *time.Time
	Team       *int64
	CreatedAt  *time.Time
	PlayerName string
	ExternalID string
}

func (q *Queries) GetMatchParticipants(ctx context.Context, matchID int64) ([]GetMatchParticipantsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMatchParticipants, matchID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMatchParticipantsRow
	for rows.Next() {
		var i GetMatchParticipantsRow
		if err := rows.Scan(
			&i.ID,
			&i.PlayerID,
			&i.MatchID,
			&i.JoinTime,
			&i.LeaveTime,
			&i.Team,
			&i.CreatedAt,
			&i.PlayerName,
			&i.ExternalID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayerMatchHistory = `-- name: GetPlayerMatchHistory :many
SELECT
    m.id as match_id,
    maps.map_name,
    m.start_time,
    m.end_time,
    mp.join_time,
    mp.leave_time,
    mp.team
FROM matches m
JOIN match_participant mp ON m.id = mp.match_id
LEFT JOIN maps ON m.map_id = maps.id
WHERE mp.player_id = (SELECT id FROM players WHERE external_id = ?)
AND m.server_id = ?
ORDER BY m.start_time DESC
LIMIT ?
`

type GetPlayerMatchHistoryParams struct {
	ExternalID string
	ServerID   int64
	Limit      int64
}

type GetPlayerMatchHistoryRow struct {
	MatchID   int64
	MapName   *string
	StartTime *time.Time
	EndTime   *time.Time
	JoinTime  *time.Time
	LeaveTime *time.Time
	Team      *int64
}

func (q *Queries) GetPlayerMatchHistory(ctx context.Context, arg GetPlayerMatchHistoryParams) ([]GetPlayerMatchHistoryRow, error) {
	rows, err := q.db.QueryContext(ctx, getPlayerMatchHistory, arg.ExternalID, arg.ServerID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlayerMatchHistoryRow
	for rows.Next() {
		var i GetPlayerMatchHistoryRow
		if err := rows.Scan(
			&i.MatchID,
			&i.MapName,
			&i.StartTime,
			&i.EndTime,
			&i.JoinTime,
			&i.LeaveTime,
			&i.Team,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
