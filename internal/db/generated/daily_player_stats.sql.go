// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: daily_player_stats.sql

package db

import (
	"context"
	"time"
)

const deleteOldDailyPlayerStats = `-- name: DeleteOldDailyPlayerStats :exec
DELETE FROM daily_player_stats WHERE date < ?
`

func (q *Queries) DeleteOldDailyPlayerStats(ctx context.Context, date time.Time) error {
	_, err := q.db.ExecContext(ctx, deleteOldDailyPlayerStats, date)
	return err
}

const getPlayerDailyTrend = `-- name: GetPlayerDailyTrend :many
SELECT date, kills, assists, deaths, games_played
FROM daily_player_stats
WHERE player_id = ?
  AND server_id = ?
  AND date >= ?
ORDER BY date DESC
`

type GetPlayerDailyTrendParams struct {
	PlayerID int64
	ServerID int64
	Date     time.Time
}

type GetPlayerDailyTrendRow struct {
	Date        time.Time
	Kills       *int64
	Assists     *int64
	Deaths      *int64
	GamesPlayed *int64
}

func (q *Queries) GetPlayerDailyTrend(ctx context.Context, arg GetPlayerDailyTrendParams) ([]GetPlayerDailyTrendRow, error) {
	rows, err := q.db.QueryContext(ctx, getPlayerDailyTrend, arg.PlayerID, arg.ServerID, arg.Date)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlayerDailyTrendRow
	for rows.Next() {
		var i GetPlayerDailyTrendRow
		if err := rows.Scan(
			&i.Date,
			&i.Kills,
			&i.Assists,
			&i.Deaths,
			&i.GamesPlayed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayerStatsForPeriod = `-- name: GetPlayerStatsForPeriod :one
SELECT 
    CAST(COALESCE(SUM(kills), 0) AS INTEGER) as total_kills,
    CAST(COALESCE(SUM(assists), 0) AS INTEGER) as total_assists,
    CAST(COALESCE(SUM(deaths), 0) AS INTEGER) as total_deaths,
    CAST(COALESCE(SUM(games_played), 0) AS INTEGER) as total_games,
    CAST(COALESCE(SUM(total_score), 0) AS INTEGER) as total_score
FROM daily_player_stats
WHERE player_id = ?
  AND server_id = ?
  AND date >= ?
`

type GetPlayerStatsForPeriodParams struct {
	PlayerID int64
	ServerID int64
	Date     time.Time
}

type GetPlayerStatsForPeriodRow struct {
	TotalKills   int64
	TotalAssists int64
	TotalDeaths  int64
	TotalGames   int64
	TotalScore   int64
}

func (q *Queries) GetPlayerStatsForPeriod(ctx context.Context, arg GetPlayerStatsForPeriodParams) (GetPlayerStatsForPeriodRow, error) {
	row := q.db.QueryRowContext(ctx, getPlayerStatsForPeriod, arg.PlayerID, arg.ServerID, arg.Date)
	var i GetPlayerStatsForPeriodRow
	err := row.Scan(
		&i.TotalKills,
		&i.TotalAssists,
		&i.TotalDeaths,
		&i.TotalGames,
		&i.TotalScore,
	)
	return i, err
}

const getTopPlayersByKillsForPeriod = `-- name: GetTopPlayersByKillsForPeriod :many
SELECT 
    p.id,
    p.name,
    CAST(COALESCE(SUM(d.kills), 0) AS INTEGER) as total_kills,
    CAST(COALESCE(SUM(d.assists), 0) AS INTEGER) as total_assists,
    CAST(COALESCE(SUM(d.deaths), 0) AS INTEGER) as total_deaths
FROM daily_player_stats d
JOIN players p ON d.player_id = p.id
WHERE d.server_id = ?
  AND d.date >= ?
GROUP BY d.player_id, p.id, p.name
ORDER BY total_kills DESC
LIMIT ?
`

type GetTopPlayersByKillsForPeriodParams struct {
	ServerID int64
	Date     time.Time
	Limit    int64
}

type GetTopPlayersByKillsForPeriodRow struct {
	ID           int64
	Name         string
	TotalKills   int64
	TotalAssists int64
	TotalDeaths  int64
}

func (q *Queries) GetTopPlayersByKillsForPeriod(ctx context.Context, arg GetTopPlayersByKillsForPeriodParams) ([]GetTopPlayersByKillsForPeriodRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopPlayersByKillsForPeriod, arg.ServerID, arg.Date, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopPlayersByKillsForPeriodRow
	for rows.Next() {
		var i GetTopPlayersByKillsForPeriodRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.TotalKills,
			&i.TotalAssists,
			&i.TotalDeaths,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertDailyPlayerStats = `-- name: UpsertDailyPlayerStats :one
INSERT INTO daily_player_stats (player_id, server_id, date, kills, assists, deaths, games_played, total_score)
VALUES (?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(player_id, server_id, date) DO UPDATE SET
    kills = daily_player_stats.kills + excluded.kills,
    assists = daily_player_stats.assists + excluded.assists,
    deaths = daily_player_stats.deaths + excluded.deaths,
    games_played = daily_player_stats.games_played + excluded.games_played,
    total_score = daily_player_stats.total_score + excluded.total_score
RETURNING player_id, server_id, date, kills, assists, deaths, games_played, total_score
`

type UpsertDailyPlayerStatsParams struct {
	PlayerID    int64
	ServerID    int64
	Date        time.Time
	Kills       *int64
	Assists     *int64
	Deaths      *int64
	GamesPlayed *int64
	TotalScore  *int64
}

func (q *Queries) UpsertDailyPlayerStats(ctx context.Context, arg UpsertDailyPlayerStatsParams) (DailyPlayerStat, error) {
	row := q.db.QueryRowContext(ctx, upsertDailyPlayerStats,
		arg.PlayerID,
		arg.ServerID,
		arg.Date,
		arg.Kills,
		arg.Assists,
		arg.Deaths,
		arg.GamesPlayed,
		arg.TotalScore,
	)
	var i DailyPlayerStat
	err := row.Scan(
		&i.PlayerID,
		&i.ServerID,
		&i.Date,
		&i.Kills,
		&i.Assists,
		&i.Deaths,
		&i.GamesPlayed,
		&i.TotalScore,
	)
	return i, err
}
