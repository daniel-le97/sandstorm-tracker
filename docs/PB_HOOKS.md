Extend with Go - Event hooks
The standard way to modify PocketBase is through event hooks in your Go code.

All hooks have 3 main methods:
- Bind(handler) adds a new handler to the specified event hook. A handler has 3 fields:
- Id (optional) - the name of the handler (could be used as argument for Unbind)
- Priority (optional) - the execution order of the handler (if empty fallbacks to the order of registration in the code).
- Func (required) - the handler function.

BindFunc(func) is similar to Bind but registers a new handler from just the provided function.
The registered handler is added with a default 0 priority and the id is autogenerated (the returned string value).

Trigger(event, oneOffHandlerFuncs...) triggers the event hook.
This method rarely has to be called manually by users.

To remove an already registered hook handler, you can use the handler id and pass it to Unbind(id) or remove all handlers with UnbindAll() (!including system handlers).

All hook handler functions share the same func(e T) error signature and expect the user to call e.Next() if they want to proceed with the execution chain.

If you need to access the app instance from inside a hook handler, prefer using the e.App field instead of reusing a parent scope app variable because the hook could be part of a DB transaction and can cause deadlock.

Also avoid using global mutex locks inside a hook handler because it could be invoked recursively (e.g. cascade delete) and can cause deadlock.


Intercepting logs write
If you want to modify the log data before persisting in the database or to forward it to an external system, then you can listen for changes of the _logs table by attaching to the base model hooks. For example:

app.OnModelCreate(core.LogsTableName).BindFunc(func(e *core.ModelEvent) error {
    l := e.Model.(*core.Log)

    fmt.Println(l.Id)
    fmt.Println(l.Created)
    fmt.Println(l.Level)
    fmt.Println(l.Message)
    fmt.Println(l.Data)

    return e.Next()
})