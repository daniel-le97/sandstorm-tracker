// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: weapon_stats.sql

package db

import (
	"context"
)

const deleteWeaponStats = `-- name: DeleteWeaponStats :exec
DELETE FROM weapon_stats WHERE player_stats_id = ? AND weapon_name = ?
`

type DeleteWeaponStatsParams struct {
	PlayerStatsID string
	WeaponName    string
}

func (q *Queries) DeleteWeaponStats(ctx context.Context, arg DeleteWeaponStatsParams) error {
	_, err := q.db.ExecContext(ctx, deleteWeaponStats, arg.PlayerStatsID, arg.WeaponName)
	return err
}

const getPlayerStatsWithKills = `-- name: GetPlayerStatsWithKills :many
SELECT ps.id, ps.player_id, ps.server_id, ps.games_played, ps.wins, ps.losses, ps.total_score, ps.total_play_time, ps.last_login, ps.total_deaths, ps.friendly_fire_kills, ps.highest_score, p.name as player_name, CAST(COALESCE(SUM(ws.kills), 0) AS INTEGER) as total_kills
FROM player_stats ps
JOIN players p ON ps.player_id = p.id
LEFT JOIN weapon_stats ws ON ps.id = ws.player_stats_id
WHERE ps.server_id = ?
GROUP BY ps.id, p.name
ORDER BY total_kills DESC
`

type GetPlayerStatsWithKillsRow struct {
	ID                string
	PlayerID          int64
	ServerID          int64
	GamesPlayed       *int64
	Wins              *int64
	Losses            *int64
	TotalScore        *int64
	TotalPlayTime     *int64
	LastLogin         *string
	TotalDeaths       *int64
	FriendlyFireKills *int64
	HighestScore      *int64
	PlayerName        string
	TotalKills        int64
}

func (q *Queries) GetPlayerStatsWithKills(ctx context.Context, serverID int64) ([]GetPlayerStatsWithKillsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPlayerStatsWithKills, serverID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlayerStatsWithKillsRow
	for rows.Next() {
		var i GetPlayerStatsWithKillsRow
		if err := rows.Scan(
			&i.ID,
			&i.PlayerID,
			&i.ServerID,
			&i.GamesPlayed,
			&i.Wins,
			&i.Losses,
			&i.TotalScore,
			&i.TotalPlayTime,
			&i.LastLogin,
			&i.TotalDeaths,
			&i.FriendlyFireKills,
			&i.HighestScore,
			&i.PlayerName,
			&i.TotalKills,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopWeaponsForPlayer = `-- name: GetTopWeaponsForPlayer :many
SELECT weapon_name, kills, assists 
FROM weapon_stats 
WHERE player_stats_id = ? AND kills > 0
ORDER BY kills DESC
LIMIT ?
`

type GetTopWeaponsForPlayerParams struct {
	PlayerStatsID string
	Limit         int64
}

type GetTopWeaponsForPlayerRow struct {
	WeaponName string
	Kills      *int64
	Assists    *int64
}

func (q *Queries) GetTopWeaponsForPlayer(ctx context.Context, arg GetTopWeaponsForPlayerParams) ([]GetTopWeaponsForPlayerRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopWeaponsForPlayer, arg.PlayerStatsID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopWeaponsForPlayerRow
	for rows.Next() {
		var i GetTopWeaponsForPlayerRow
		if err := rows.Scan(&i.WeaponName, &i.Kills, &i.Assists); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalKillsForPlayerStats = `-- name: GetTotalKillsForPlayerStats :one
SELECT CAST(COALESCE(SUM(kills), 0) AS INTEGER) as total_kills FROM weapon_stats WHERE player_stats_id = ?
`

func (q *Queries) GetTotalKillsForPlayerStats(ctx context.Context, playerStatsID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getTotalKillsForPlayerStats, playerStatsID)
	var total_kills int64
	err := row.Scan(&total_kills)
	return total_kills, err
}

const getWeaponStatsForPlayerStats = `-- name: GetWeaponStatsForPlayerStats :many
SELECT player_stats_id, weapon_name, kills, assists FROM weapon_stats WHERE player_stats_id = ?
`

func (q *Queries) GetWeaponStatsForPlayerStats(ctx context.Context, playerStatsID string) ([]WeaponStat, error) {
	rows, err := q.db.QueryContext(ctx, getWeaponStatsForPlayerStats, playerStatsID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WeaponStat
	for rows.Next() {
		var i WeaponStat
		if err := rows.Scan(
			&i.PlayerStatsID,
			&i.WeaponName,
			&i.Kills,
			&i.Assists,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertWeaponStats = `-- name: UpsertWeaponStats :one
INSERT INTO weapon_stats (player_stats_id, weapon_name, kills, assists)
VALUES (?, ?, ?, ?)
ON CONFLICT(player_stats_id, weapon_name) DO UPDATE SET
    kills = weapon_stats.kills + excluded.kills,
    assists = weapon_stats.assists + excluded.assists
RETURNING player_stats_id, weapon_name, kills, assists
`

type UpsertWeaponStatsParams struct {
	PlayerStatsID string
	WeaponName    string
	Kills         *int64
	Assists       *int64
}

func (q *Queries) UpsertWeaponStats(ctx context.Context, arg UpsertWeaponStatsParams) (WeaponStat, error) {
	row := q.db.QueryRowContext(ctx, upsertWeaponStats,
		arg.PlayerStatsID,
		arg.WeaponName,
		arg.Kills,
		arg.Assists,
	)
	var i WeaponStat
	err := row.Scan(
		&i.PlayerStatsID,
		&i.WeaponName,
		&i.Kills,
		&i.Assists,
	)
	return i, err
}
